# CIDR 병합
> CIDR 병합은 여러 개의 CIDR를 하나의 큰 CIDR로 합치는 기능이다. 

## 병합 가능 조건
1. **같은 크기여야 함** (같은 prefix 길이)
2. **서로 붙어있어야 한다** (인접한 주소)
3. **2의 거듭제곱 개수여야 함** (2개, 4개, 8개 ...)
4. **올바른 네트워크 경계에 정렬되어야 함**

## 🎯 간단한 예시로 이해하기

### 기본 병합 (2개)
```
입력: 192.168.1.0/25   (IP: .0 ~ .127)
     192.168.1.128/25 (IP: .128 ~ .255)

조건 체크:
✅ 같은 크기: 둘 다 /25
✅ 인접함: .127 다음이 .128
✅ 2개 = 2¹

결과: 192.168.1.0/24   (IP: .0 ~ .255)
```

### 4개 병합
```
입력: 192.168.1.0/26   (.0 ~ .63)
     192.168.1.64/26  (.64 ~ .127)
     192.168.1.128/26 (.128 ~ .191)
     192.168.1.192/26 (.192 ~ .255)

조건 체크:
✅ 같은 크기: 모두 /26
✅ 연속적: .63→.64, .127→.128, .191→.192
✅ 4개 = 2²

결과: 192.168.1.0/24   (.0 ~ .255)
```

### 병합 불가능한 경우
```
입력: 192.168.1.0/26   (.0 ~ .63)
     192.168.1.128/26 (.128 ~ .191)  ← 중간에 .64~.127 빠짐!

조건 체크:
✅ 같은 크기: 둘 다 /26
❌ 인접하지 않음: .63 다음이 .128이 아님

결과: 병합 불가능 → 그대로 유지
```

## 🔧 구현할 목록
1. **자동 정렬**: CIDR을 네트워크 주소 순으로 정렬 
2. **인접성 검사**: 연속된 주소 범위인지 확인 
3. **2의 거듭제곱 병합**: 2개, 4개, 8개씩 묶어서 병합 
4. **재귀적 병합**: 여러 단계에 걸쳐 최적화 
5. **부분 병합**: 일부만 병합 가능한 경우 처리 

## 📐 Prefix Length 계산 공식

```
새로운_prefix = 기존_prefix - log₂(병합할_개수)

예시:
• 2개 병합: /25 - log₂(2) = /25 - 1 = /24
• 4개 병합: /26 - log₂(4) = /26 - 2 = /24  
• 8개 병합: /27 - log₂(8) = /27 - 3 = /24
```

## 🧮 알고리즘 단계

### 1단계: 전처리
```
1. 모든 CIDR을 정규화 (192.168.1.100/24 → 192.168.1.0/24)
2. 네트워크 주소 순으로 정렬
3. 중복 제거
```

### 2단계: 그룹핑
```
1. 같은 prefix length를 가진 CIDR들끼리 묶기
2. 인접한 CIDR들끼리 그룹 만들기
3. 각 그룹에서 2의 거듭제곱 개수만큼 병합 가능한지 확인
```

### 3단계: 병합 실행
```
1. 각 그룹에서 가장 큰 병합 가능한 크기 찾기 (8개 → 4개 → 2개 순)
2. 병합 수행: 첫 번째 네트워크 주소 + 새로운 prefix
3. 병합되지 않은 CIDR들은 그대로 유지
```

### 4단계: 재귀 확인
```
1. 병합 결과에서 또 병합 가능한 것이 있는지 확인
2. 있다면 2단계부터 다시 반복
3. 더 이상 병합할 수 없을 때까지 계속
```

## 💡 핵심 기술들

### A. 인접성 검사
```java
// 두 CIDR가 붙어있는지 확인
boolean areAdjacent(CidrBlock cidr1, CidrBlock cidr2) {
    long network1 = getNetworkAddress(cidr1);
    long network2 = getNetworkAddress(cidr2);
    long cidrSize = 1L << (32 - cidr1.getPrefixLength());
    
    return (network2 - network1) == cidrSize;
}
```

### B. 2의 거듭제곱 체크
```java
// 비트 트릭: n이 2의 거듭제곱인지 확인
boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// 원리: 2의 거듭제곱은 비트에서 1이 하나만 있음
// 예시:
// 1 = 0001₂, 1-1 = 0000₂ → 0001 & 0000 = 0000 ✅
// 2 = 0010₂, 2-1 = 0001₂ → 0010 & 0001 = 0000 ✅  
// 4 = 0100₂, 4-1 = 0011₂ → 0100 & 0011 = 0000 ✅
// 8 = 1000₂, 8-1 = 0111₂ → 1000 & 0111 = 0000 ✅

// 2의 거듭제곱이 아닌 경우:
// 3 = 0011₂, 3-1 = 0010₂ → 0011 & 0010 = 0010 ≠ 0 ❌
// 5 = 0101₂, 5-1 = 0100₂ → 0101 & 0100 = 0100 ≠ 0 ❌
// 6 = 0110₂, 6-1 = 0101₂ → 0110 & 0101 = 0100 ≠ 0 ❌
```

### C. 경계 정렬 확인
```java
// 병합 후 올바른 네트워크 경계에 맞는지 확인
boolean isAligned(long networkAddress, int newPrefixLength) {
    long newCidrSize = 1L << (32 - newPrefixLength);
    return (networkAddress % newCidrSize) == 0;
}

// 예시:
// 192.168.1.64/25로 병합하려면 64가 128의 배수여야 함
// 64 % 128 = 64 ≠ 0 → 병합 불가!
// 192.168.1.0/25로 병합하려면 0이 128의 배수여야 함  
// 0 % 128 = 0 → 병합 가능!
```

## 🚨 주의사항

### 1. 메모리 효율성
- 큰 네트워크 병합 시 메모리 사용량 주의
- 재귀 깊이 제한 고려

### 2. 입력 검증
- 잘못된 CIDR 형식 처리
- null, 빈 리스트 처리
- 중복 CIDR 처리

### 3. 성능 최적화
- 정렬 알고리즘 선택
- 불필요한 재귀 방지
- 조기 종료 조건 설정

## 🧪 테스트 케이스

### 정상 케이스
```
입력: [192.168.1.0/25, 192.168.1.128/25]
출력: [192.168.1.0/24]

입력: [10.0.0.0/26, 10.0.0.64/26, 10.0.0.128/26, 10.0.0.192/26]
출력: [10.0.0.0/24]
```

### 부분 병합 케이스
```
입력: [192.168.1.0/26, 192.168.1.64/26, 192.168.2.0/26]
출력: [192.168.1.0/25, 192.168.2.0/26]
```

### 병합 불가능 케이스
```
입력: [192.168.1.0/24, 192.168.3.0/24]  ← 192.168.2.0/24 빠짐
출력: [192.168.1.0/24, 192.168.3.0/24]  ← 변화 없음

입력: [192.168.1.0/25, 192.168.1.128/26]  ← 크기 다름
출력: [192.168.1.0/25, 192.168.1.128/26]  ← 변화 없음
```

## 🎓 고급 주제

### 다단계 병합
```
1차: /27 × 8개 → /24 × 2개
2차: /24 × 2개 → /23 × 1개 (인접한 경우)
```

### 최적화 전략
```
1. 정렬된 입력 활용
2. 비트 연산 최적화
3. 메모이제이션 적용
4. 병렬 처리 고려
```

---
*이 문서는 CIDR 병합의 핵심 개념과 구현 방법을 담고 있습니다.* 

